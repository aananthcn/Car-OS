#
# Created on Mon Feb 19 2024 7:09:46 PM
#
# The MIT License (MIT)
# Copyright (c) 2024 Aananth C N
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software
# and associated documentation files (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial
# portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#

import os

import utils.search as search

import gui.car_os.code_gen as code_gen


TcpIpGeneralCfgType_str = "\n\ntypedef struct {\n\
    uint16 mainfn_period_ms;\n\
    uint32 tcpip_buffer_mem;\n\
} TcpIpGeneralCfgType;\n\
\n"

TcpIpDomainType_str = "\ntypedef enum {\n\
    TCPIP_AF_INET,\n\
    TCPIP_AF_INET6,\n\
    TCPIP_MAX_DOMAIN_TYPE\n\
} TcpIpDomainType;\n\
\n"

TcpIpAddressType_str = "\ntypedef enum {\n\
    TCPIP_UNICAST,\n\
    TCPIP_ANYCAST,\n\
    TCPIP_MULTCAST,\n\
    TCPIP_MAX_ADDR_TYPE\n\
} TcpIpAddressType;\n\
\n"

TcpIpAssignmentLifetime_str = "\ntypedef enum {\n\
    TCPIP_FORGET,\n\
    TCPIP_STORE,\n\
    TCPIP_MAX_ASSN_LIFETIME\n\
} TcpIpAssignmentLifetime;\n\
\n"

TcpIpAssignmentMethod_str = "\ntypedef enum {\n\
    TCPIP_STATIC,\n\
    TCPIP_DHCP,\n\
    TCPIP_LINKLOCAL,\n\
    TCPIP_IPV6_ROUTER,\n\
    TCPIP_LINKLOCAL_DOIP,\n\
    TCPIP_MAX_ASSN_METHOD\n\
} TcpIpAssignmentMethod;\n\
\n"

TcpIpAssignmentTrigger_str = "\ntypedef enum {\n\
    TCPIP_MANUAL,\n\
    TCPIP_AUTOMATIC,\n\
    TCPIP_MAX_ASSN_TRIGGER\n\
} TcpIpAssignmentTrigger;\n\
\n"

TcpIpLocalAddr_str = "\ntypedef struct {\n\
    uint16                    addr_id;\n\
    TcpIpDomainType           domain_type;\n\
    TcpIpAddressType          addr_type;\n\
    TcpIpAssignmentLifetime   addr_assn_life;\n\
    TcpIpAssignmentMethod     addr_assn_method;\n\
    uint8                     addr_assn_prio;\n\
    TcpIpAssignmentTrigger    addr_assn_trig;\n\
    uint16                    ip_addr[16]; /* supports both ipv6 and ipv4 */\n\
    uint16                    ip_netmask[16]; /* supports both ipv6 and ipv4 */\n\
    uint16                    ip_default_router[16]; /* supports both ipv6 and ipv4 */\n\
} TcpIpLocalAddr;\n\
\n"

TcpIp_ConfigType_str = "\ntypedef struct {\n\
    TcpIpGeneralCfgType *gen;\n\
    TcpIpLocalAddr *local_addr;\n\
} TcpIp_ConfigType;\n\
\n"


def ip_to_string(cfg, item):
    ip_range = 0
    ip_addr = None
    ret_str = "{"
    if cfg["TcpIpDomainType"] == "TCPIP_AF_INET":
        ip_range = 4
        ip_addr = cfg["TcpIpStaticIpAddressConfig"][item].split(".")
    else:
        ip_range = 16
        ip_addr = cfg["TcpIpStaticIpAddressConfig"][item].split(":")
    for j in range(16):
        if j < ip_range:
            ret_str += str(ip_addr[j])
        else:
            ret_str += "0"

        # end of initializer
        if j < 15:
            ret_str += ", "
    ret_str += "}"
    return ret_str



def generate_sourcefile(tcpip_src_path, tcpip_configs):
    cf = open(tcpip_src_path+"/cfg/TcpIp_cfg.c", "w")
    cf.write("#include <stddef.h>\n")
    cf.write("#include \"TcpIp_cfg.h\"\n\n\n")
    cf.write("// This file is autogenerated, any hand modifications will be lost!\n\n")

    TcpIpGeneral_cfg = tcpip_configs["TcpIpGeneral"][0]
    TcpIpLocalAddr_cfg = tcpip_configs["TcpIpLocalAddr"]


    cf.write("\n\nconst TcpIpGeneralCfgType TcpIpGeneralConfigs = {\n")
    cf.write("\t.mainfn_period_ms = "+str(int(1000*float(TcpIpGeneral_cfg["TcpIpMainFunctionPeriod"])))+",\n")
    cf.write("\t.tcpip_buffer_mem = "+str(TcpIpGeneral_cfg["TcpIpBufferMemory"])+"\n")
    cf.write("};\n")


    cf.write("\nconst TcpIpLocalAddr TcpIpLocalAddrConfigs[MAX_TCPIP_LOCAL_ADDRESS] = {\n")
    for i, cfg in enumerate(TcpIpLocalAddr_cfg):
        cf.write("\t{\n")
        cf.write("\t\t/* TcpIp local address - "+str(i)+" */\n")
        cf.write("\t\t.addr_id = "+cfg["TcpIpAddrId"]+",\n")
        cf.write("\t\t.domain_type = "+cfg["TcpIpDomainType"]+",\n")
        cf.write("\t\t.addr_type = "+cfg["TcpIpAddressType"]+",\n")
        cf.write("\t\t.addr_assn_life = "+cfg["TcpIpAddrAssignment"]["TcpIpAssignmentLifetime"]+",\n")
        cf.write("\t\t.addr_assn_method = "+cfg["TcpIpAddrAssignment"]["TcpIpAssignmentMethod"]+",\n")
        cf.write("\t\t.addr_assn_prio = "+cfg["TcpIpAddrAssignment"]["TcpIpAssignmentPriority"]+",\n")
        cf.write("\t\t.addr_assn_trig = "+cfg["TcpIpAddrAssignment"]["TcpIpAssignmentTrigger"]+",\n")
        cf.write("\t\t.ip_addr = "+ip_to_string(cfg, "TcpIpStaticIpAddress")+",\n")
        cf.write("\t\t.ip_netmask = "+ip_to_string(cfg, "TcpIpNetmask")+",\n")
        cf.write("\t\t.ip_default_router = "+ip_to_string(cfg, "TcpIpDefaultRouter")+"\n")
        cf.write("\t}\n")
    cf.write("};\n\n")


    cf.write("\nconst TcpIp_ConfigType TcpIp_Config = {\n")
    cf.write("\t.gen = &TcpIpGeneralConfigs,\n")
    cf.write("\t.local_addr = &TcpIpLocalAddrConfigs\n")
    cf.write("};\n\n")

    cf.close()



def generate_headerfile(tcpip_src_path, tcpip_configs):
    hf = open(tcpip_src_path+"/cfg/TcpIp_cfg.h", "w")
    hf.write("#ifndef CAR_OS_TCP_IP_H\n")
    hf.write("#define CAR_OS_TCP_IP_H\n\n")
    hf.write("// This file is autogenerated, any hand modifications will be lost!\n\n")
    hf.write("#include <Platform_Types.h>\n\n")


    hf.write(TcpIpDomainType_str)
    hf.write(TcpIpAddressType_str)
    hf.write(TcpIpAssignmentMethod_str)
    hf.write(TcpIpAssignmentTrigger_str)
    hf.write(TcpIpAssignmentLifetime_str)

    hf.write(TcpIpGeneralCfgType_str)
    hf.write(TcpIpLocalAddr_str)
    hf.write("\n\n#define MAX_TCPIP_LOCAL_ADDRESS     ("+str(len(tcpip_configs["TcpIpLocalAddr"]))+")\n\n")

    hf.write(TcpIp_ConfigType_str)
    hf.write("\nextern const TcpIp_ConfigType TcpIp_Config;\n")
    hf.write("\n\n#endif\n")
    hf.close()



def generate_code(gui, view):
    cwd = os.getcwd()
    if os.path.exists(os.getcwd()+"/car-os"):
        tcpip_src_path = search.find_dir("TcpIp", cwd+"/car-os/submodules/SL/")
    else:
        tcpip_src_path = search.find_dir("TcpIp", cwd+"/submodules/SL/")

    generate_headerfile(tcpip_src_path, view)
    generate_sourcefile(tcpip_src_path, view)
    code_gen.create_build_files(gui)
